// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'file.freezed.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `AppState`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

/// 1.1 dart打开文件 -> rust后台开启线程处理文件
Future<void> openFile({required String path}) =>
    RustLib.instance.api.crateFileOpenFile(path: path);

/// 1.2 dart查询文件状态
Future<FileStatus> getFileStatus() =>
    RustLib.instance.api.crateFileGetFileStatus();

/// 1.3 dart查询日志 （这里不返回详细信息)
/// filter_sql: SQL WHERE clause fragment (e.g., "eventName = 'Error'")
/// fts_query: Full text search query
Future<Logs> getLogs({
  required String filterSql,
  required String ftsQuery,
  required int limit,
  required int offset,
}) => RustLib.instance.api.crateFileGetLogs(
  filterSql: filterSql,
  ftsQuery: ftsQuery,
  limit: limit,
  offset: offset,
);

/// 1.4 dart查询特定日志的详细信息
Future<String?> getLogDetail({required int id}) =>
    RustLib.instance.api.crateFileGetLogDetail(id: id);

/// 1.5 dart查询某个字段的可能值 (用于自动补全)
Future<List<String>> getFieldValues({
  required String field,
  required String search,
  required int limit,
  required int offset,
}) => RustLib.instance.api.crateFileGetFieldValues(
  field: field,
  search: search,
  limit: limit,
  offset: offset,
);

Future<RenderConfig> getRenderConfig() =>
    RustLib.instance.api.crateFileGetRenderConfig();

@freezed
sealed class FileStatus with _$FileStatus {
  const FileStatus._();

  const factory FileStatus.uninit() = FileStatus_Uninit;
  const factory FileStatus.pending() = FileStatus_Pending;
  const factory FileStatus.complete() = FileStatus_Complete;
  const factory FileStatus.error(String field0) = FileStatus_Error;
}

class Log {
  final int id;
  final Map<String, String> fields;

  const Log({required this.id, required this.fields});

  @override
  int get hashCode => id.hashCode ^ fields.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Log &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          fields == other.fields;
}

class Logs {
  final List<Log> logs;
  final int totalCount;

  const Logs({required this.logs, required this.totalCount});

  @override
  int get hashCode => logs.hashCode ^ totalCount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Logs &&
          runtimeType == other.runtimeType &&
          logs == other.logs &&
          totalCount == other.totalCount;
}

class RenderCell {
  final String expr;
  final String? style;
  final int? maxLines;
  final bool? ellipsis;

  const RenderCell({
    required this.expr,
    this.style,
    this.maxLines,
    this.ellipsis,
  });

  @override
  int get hashCode =>
      expr.hashCode ^ style.hashCode ^ maxLines.hashCode ^ ellipsis.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RenderCell &&
          runtimeType == other.runtimeType &&
          expr == other.expr &&
          style == other.style &&
          maxLines == other.maxLines &&
          ellipsis == other.ellipsis;
}

class RenderColumn {
  final double? width;
  final int? flex;
  final List<RenderCell> rows;

  const RenderColumn({this.width, this.flex, required this.rows});

  @override
  int get hashCode => width.hashCode ^ flex.hashCode ^ rows.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RenderColumn &&
          runtimeType == other.runtimeType &&
          width == other.width &&
          flex == other.flex &&
          rows == other.rows;
}

class RenderConfig {
  final List<RenderColumn> columns;
  final List<String> fields;

  const RenderConfig({required this.columns, required this.fields});

  @override
  int get hashCode => columns.hashCode ^ fields.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RenderConfig &&
          runtimeType == other.runtimeType &&
          columns == other.columns &&
          fields == other.fields;
}
